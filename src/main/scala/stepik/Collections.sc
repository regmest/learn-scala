// Виды коллекций:
// ---------------
//    - immutable (List[+A], Stream[+A], Vector[+A], Set[+A], Map[K, +V]) - import scala.collection.immutable._
//    - mutable (Buffer[A], Set[A], Map[A, B], Builder[-E, +C] - import scala.collection.mutable._
// Их ^^ общие надтипы лежат в пакете import from scala.collection._ (Seq[+A], Set[+A], Map[K, +V], Iterator[+A])
//    - специализированные коллекции - Array[A], String


// Array (специализированная коллекция)
// -----
// - Очень эффективный низкоуровневый набор элементов
// - Фиксированного размера
// - Эффективен в том числе и потому, что у него есть специализированные версии для примитивных типов (Int, Long, Double, Boolean)

val ints = Array(1,2,3,5) // выделяется массив фиксированной заранее известной длины
ints(2)
ints(2) = 6
ints(2) // 6
// ints(4) // java.lang.ArrayIndexOutOfBoundsException

// String (специализированная коллекция)
// ------
// - тоже массив символов
// - но неизменяемый - любое изменение выделяет новую строку
val lang = "Scala"
val platform = "Stepik"
// Конкатенация - не самый эффективный способ, для каждого промежуточного действия выделяется новая строка
val course = lang + " " + platform
// Интерполяция гораздо эффективнее
val course1 = s"$lang $platform"
// Вытащить символ по индексу
val char: Char = course(3)


// Mutable
// -------
// - Состояние может меняться со временем
// - Эффективнее неизменяемых коллекций при большом количестве операций подряд
// - Копирование их не эффективно (чтобы скопировать изменяемую коллекцию, нужно выделить новое место
// для всех элементов и скопировать каждый в новую коллекцию)

// Buffer[A] - массив, в который можно добрасывать элементы с конца; "саморастущий массив"
// Set[A] - коллекция уникальных элементов
// Map[K, V] - ассоциативный массив "ключ-значение"
// Builder[E, Coll] - специальный промежуточный тип, накопитель для построения коллекции

import scala.collection.mutable

val strings = mutable.Buffer[String]()
strings += "hello" // мутация
strings += "scala"
strings.mkString(" ")


// Immutable
// ---------
// - Состояние неизменно
// - При изменении эффективное создание копий с переиспользованием пространства коллекций из которых создается новый элемент
// - Тк не изменяются, они Hashable, могут храниться в Set, быть ключами в Map

// List[A]    - Односвязный конечный список, легко добавить элемент в начало
// Stream[A]  - Ленивый односвязный список ("хвост" вычисляется лениво), лекго добавить элемент в начало,
// вомзножно бесконечный (тк из-за "ленивости" может не держать в памяти все элементы)
// Vector[A]  - Индексированный список, легко получить элемент по индексу, добавить элемент в начало или конец
// Set[A] - набор уникальных элементов
// Map[K, V] - ассоциативный массив "ключ-значение"

val initial = Vector[String]("stepik") // Vector(stepik)
val mid = "scala" +: "+" +: initial // добавляем элементы в начало; Vector(scala, +, stepik)
val str = mid :+ "=" :+ "love"      // добавляем элементы в конец;  Vector(scala, +, stepik, =, love)

str.mkString(" ") // String = scala + stepik = love

// Практика
// --------
val list = List(2,5,7,1,4)
list.sorted // List(1, 2, 4, 5, 7)

// создаем коллекцию произвольного размера
List.fill(10)(2) // создаст коллекцию с десятью двойками List(2, 2, 2, 2, 2, 2, 2, 2, 2, 2)
List.fill(3,4)(2) // список с тремя списками по 4 двойки List(List(2, 2, 2, 2), List(2, 2, 2, 2), List(2, 2, 2, 2))
List.fill(3,4,5)(2) // список с треся списками по 4 списка по 5 двоек
import scala.util.Random
Random.nextInt(10) // value from 0 to 9
val randomList = List.fill(Random.nextInt(100))(Random.nextInt(1000)) // List(575, 529, 723, 1, 932, 289, 731, 104, 13, 294, 191 ...

// классический, эффективный и хорошо подходяший для односвязных списков способ сортировки - сортировка слиянием